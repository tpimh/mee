/* my.ptrlist.c generated by valac 0.20.0, the Vala compiler
 * generated from my.ptrlist.vala, do not modify */


#include <glib.h>
#include <glib-object.h>


#define MY_TYPE_ILIST (my_ilist_get_type ())
#define MY_ILIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MY_TYPE_ILIST, MyIList))
#define MY_IS_ILIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MY_TYPE_ILIST))
#define MY_ILIST_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), MY_TYPE_ILIST, MyIListIface))

typedef struct _MyIList MyIList;
typedef struct _MyIListIface MyIListIface;

#define MY_TYPE_ITERABLE (my_iterable_get_type ())
#define MY_ITERABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MY_TYPE_ITERABLE, MyIterable))
#define MY_IS_ITERABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MY_TYPE_ITERABLE))
#define MY_ITERABLE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), MY_TYPE_ITERABLE, MyIterableIface))

typedef struct _MyIterable MyIterable;
typedef struct _MyIterableIface MyIterableIface;

#define MY_TYPE_ITERATOR (my_iterator_get_type ())
#define MY_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MY_TYPE_ITERATOR, MyIterator))
#define MY_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MY_TYPE_ITERATOR, MyIteratorClass))
#define MY_IS_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MY_TYPE_ITERATOR))
#define MY_IS_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MY_TYPE_ITERATOR))
#define MY_ITERATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MY_TYPE_ITERATOR, MyIteratorClass))

typedef struct _MyIterator MyIterator;
typedef struct _MyIteratorClass MyIteratorClass;

#define MY_TYPE_IEQUATABLE (my_iequatable_get_type ())
#define MY_IEQUATABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MY_TYPE_IEQUATABLE, MyIEquatable))
#define MY_IS_IEQUATABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MY_TYPE_IEQUATABLE))
#define MY_IEQUATABLE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), MY_TYPE_IEQUATABLE, MyIEquatableIface))

typedef struct _MyIEquatable MyIEquatable;
typedef struct _MyIEquatableIface MyIEquatableIface;

#define MY_TYPE_LIST (my_list_get_type ())
#define MY_LIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MY_TYPE_LIST, MyList))
#define MY_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MY_TYPE_LIST, MyListClass))
#define MY_IS_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MY_TYPE_LIST))
#define MY_IS_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MY_TYPE_LIST))
#define MY_LIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MY_TYPE_LIST, MyListClass))

typedef struct _MyList MyList;
typedef struct _MyListClass MyListClass;
typedef struct _MyListPrivate MyListPrivate;

#define MY_TYPE_PTR_LIST (my_ptr_list_get_type ())
#define MY_PTR_LIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MY_TYPE_PTR_LIST, MyPtrList))
#define MY_PTR_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MY_TYPE_PTR_LIST, MyPtrListClass))
#define MY_IS_PTR_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MY_TYPE_PTR_LIST))
#define MY_IS_PTR_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MY_TYPE_PTR_LIST))
#define MY_PTR_LIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MY_TYPE_PTR_LIST, MyPtrListClass))

typedef struct _MyPtrList MyPtrList;
typedef struct _MyPtrListClass MyPtrListClass;
typedef struct _MyPtrListPrivate MyPtrListPrivate;

struct _MyIListIface {
	GTypeInterface parent_iface;
	gpointer (*get) (MyIList* self, gint index);
	void (*set) (MyIList* self, gint index, gconstpointer val);
	void (*add) (MyIList* self, gconstpointer item);
	void (*add_range) (MyIList* self, gpointer* items, int items_length1);
	void (*add_collection) (MyIList* self, MyIList* coll);
	gboolean (*contains) (MyIList* self, gconstpointer item);
	void (*insert) (MyIList* self, gint position, gconstpointer item);
	void (*insert_all) (MyIList* self, gint position, gpointer* items, int items_length1);
	void (*insert_collection) (MyIList* self, gint position, MyIList* coll);
	void (*reverse) (MyIList* self);
	gint (*index_of) (MyIList* self, gconstpointer item);
	gint* (*index_of_all) (MyIList* self, gconstpointer item, int* result_length1);
	void (*remove) (MyIList* self, gconstpointer item);
	void (*remove_at) (MyIList* self, gint index);
	void (*remove_all) (MyIList* self, gconstpointer item);
	void (*remove_range) (MyIList* self, gint start, gint length);
	gint (*get_size) (MyIList* self);
};

struct _MyIterableIface {
	GTypeInterface parent_iface;
	MyIterator* (*iterator) (MyIterable* self);
};

struct _MyIEquatableIface {
	GTypeInterface parent_iface;
	gboolean (*equals) (MyIEquatable* self, GObject* other);
};

struct _MyList {
	GObject parent_instance;
	MyListPrivate * priv;
};

struct _MyListClass {
	GObjectClass parent_class;
};

struct _MyPtrList {
	MyList parent_instance;
	MyPtrListPrivate * priv;
};

struct _MyPtrListClass {
	MyListClass parent_class;
};


static gpointer my_ptr_list_parent_class = NULL;

GType my_ilist_get_type (void) G_GNUC_CONST;
gpointer my_iterator_ref (gpointer instance);
void my_iterator_unref (gpointer instance);
GParamSpec* my_param_spec_iterator (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void my_value_set_iterator (GValue* value, gpointer v_object);
void my_value_take_iterator (GValue* value, gpointer v_object);
gpointer my_value_get_iterator (const GValue* value);
GType my_iterator_get_type (void) G_GNUC_CONST;
GType my_iterable_get_type (void) G_GNUC_CONST;
GType my_iequatable_get_type (void) G_GNUC_CONST;
GType my_list_get_type (void) G_GNUC_CONST;
GType my_ptr_list_get_type (void) G_GNUC_CONST;
enum  {
	MY_PTR_LIST_DUMMY_PROPERTY,
	MY_PTR_LIST_DATA
};
MyPtrList* my_ptr_list_new (void);
MyPtrList* my_ptr_list_construct (GType object_type);
MyList* my_list_new (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GEqualFunc func, GCompareFunc cfunc);
MyList* my_list_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GEqualFunc func, GCompareFunc cfunc);
void** my_ptr_list_get_data (MyPtrList* self);
gpointer* my_list_to_array (MyList* self, int* result_length1);
static void _vala_my_ptr_list_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);


MyPtrList* my_ptr_list_construct (GType object_type) {
	MyPtrList * self = NULL;
	self = (MyPtrList*) my_list_construct (object_type, G_TYPE_POINTER, NULL, NULL, NULL, NULL);
	return self;
}


MyPtrList* my_ptr_list_new (void) {
	return my_ptr_list_construct (MY_TYPE_PTR_LIST);
}


void** my_ptr_list_get_data (MyPtrList* self) {
	void** result;
	gint _tmp0_ = 0;
	gpointer* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = my_list_to_array ((MyList*) self, &_tmp0_);
	result = (void*) _tmp1_;
	return result;
}


static void my_ptr_list_class_init (MyPtrListClass * klass) {
	my_ptr_list_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->get_property = _vala_my_ptr_list_get_property;
	g_object_class_install_property (G_OBJECT_CLASS (klass), MY_PTR_LIST_DATA, g_param_spec_pointer ("data", "data", "data", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void my_ptr_list_instance_init (MyPtrList * self) {
}


GType my_ptr_list_get_type (void) {
	static volatile gsize my_ptr_list_type_id__volatile = 0;
	if (g_once_init_enter (&my_ptr_list_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (MyPtrListClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) my_ptr_list_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MyPtrList), 0, (GInstanceInitFunc) my_ptr_list_instance_init, NULL };
		GType my_ptr_list_type_id;
		my_ptr_list_type_id = g_type_register_static (MY_TYPE_LIST, "MyPtrList", &g_define_type_info, 0);
		g_once_init_leave (&my_ptr_list_type_id__volatile, my_ptr_list_type_id);
	}
	return my_ptr_list_type_id__volatile;
}


static void _vala_my_ptr_list_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	MyPtrList * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, MY_TYPE_PTR_LIST, MyPtrList);
	switch (property_id) {
		case MY_PTR_LIST_DATA:
		g_value_set_pointer (value, my_ptr_list_get_data (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}




/* my.bytevector.c generated by valac 0.20.0, the Vala compiler
 * generated from my.bytevector.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>


#define MY_TYPE_ILIST (my_ilist_get_type ())
#define MY_ILIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MY_TYPE_ILIST, MyIList))
#define MY_IS_ILIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MY_TYPE_ILIST))
#define MY_ILIST_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), MY_TYPE_ILIST, MyIListIface))

typedef struct _MyIList MyIList;
typedef struct _MyIListIface MyIListIface;

#define MY_TYPE_ITERABLE (my_iterable_get_type ())
#define MY_ITERABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MY_TYPE_ITERABLE, MyIterable))
#define MY_IS_ITERABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MY_TYPE_ITERABLE))
#define MY_ITERABLE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), MY_TYPE_ITERABLE, MyIterableIface))

typedef struct _MyIterable MyIterable;
typedef struct _MyIterableIface MyIterableIface;

#define MY_TYPE_ITERATOR (my_iterator_get_type ())
#define MY_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MY_TYPE_ITERATOR, MyIterator))
#define MY_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MY_TYPE_ITERATOR, MyIteratorClass))
#define MY_IS_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MY_TYPE_ITERATOR))
#define MY_IS_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MY_TYPE_ITERATOR))
#define MY_ITERATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MY_TYPE_ITERATOR, MyIteratorClass))

typedef struct _MyIterator MyIterator;
typedef struct _MyIteratorClass MyIteratorClass;

#define MY_TYPE_IEQUATABLE (my_iequatable_get_type ())
#define MY_IEQUATABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MY_TYPE_IEQUATABLE, MyIEquatable))
#define MY_IS_IEQUATABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MY_TYPE_IEQUATABLE))
#define MY_IEQUATABLE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), MY_TYPE_IEQUATABLE, MyIEquatableIface))

typedef struct _MyIEquatable MyIEquatable;
typedef struct _MyIEquatableIface MyIEquatableIface;

#define MY_TYPE_LIST (my_list_get_type ())
#define MY_LIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MY_TYPE_LIST, MyList))
#define MY_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MY_TYPE_LIST, MyListClass))
#define MY_IS_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MY_TYPE_LIST))
#define MY_IS_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MY_TYPE_LIST))
#define MY_LIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MY_TYPE_LIST, MyListClass))

typedef struct _MyList MyList;
typedef struct _MyListClass MyListClass;
typedef struct _MyListPrivate MyListPrivate;

#define MY_TYPE_BYTE_VECTOR (my_byte_vector_get_type ())
#define MY_BYTE_VECTOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MY_TYPE_BYTE_VECTOR, MyByteVector))
#define MY_BYTE_VECTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MY_TYPE_BYTE_VECTOR, MyByteVectorClass))
#define MY_IS_BYTE_VECTOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MY_TYPE_BYTE_VECTOR))
#define MY_IS_BYTE_VECTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MY_TYPE_BYTE_VECTOR))
#define MY_BYTE_VECTOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MY_TYPE_BYTE_VECTOR, MyByteVectorClass))

typedef struct _MyByteVector MyByteVector;
typedef struct _MyByteVectorClass MyByteVectorClass;
typedef struct _MyByteVectorPrivate MyByteVectorPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define MY_TYPE_BYTE_VECTOR_COLLECTION (my_byte_vector_collection_get_type ())
#define MY_BYTE_VECTOR_COLLECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MY_TYPE_BYTE_VECTOR_COLLECTION, MyByteVectorCollection))
#define MY_BYTE_VECTOR_COLLECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MY_TYPE_BYTE_VECTOR_COLLECTION, MyByteVectorCollectionClass))
#define MY_IS_BYTE_VECTOR_COLLECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MY_TYPE_BYTE_VECTOR_COLLECTION))
#define MY_IS_BYTE_VECTOR_COLLECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MY_TYPE_BYTE_VECTOR_COLLECTION))
#define MY_BYTE_VECTOR_COLLECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MY_TYPE_BYTE_VECTOR_COLLECTION, MyByteVectorCollectionClass))

typedef struct _MyByteVectorCollection MyByteVectorCollection;
typedef struct _MyByteVectorCollectionClass MyByteVectorCollectionClass;
typedef struct _MyByteVectorCollectionPrivate MyByteVectorCollectionPrivate;

struct _MyIListIface {
	GTypeInterface parent_iface;
	gpointer (*get) (MyIList* self, gint index);
	void (*set) (MyIList* self, gint index, gconstpointer val);
	void (*add) (MyIList* self, gconstpointer item);
	void (*add_range) (MyIList* self, gpointer* items, int items_length1);
	void (*add_collection) (MyIList* self, MyIList* coll);
	gboolean (*contains) (MyIList* self, gconstpointer item);
	void (*insert) (MyIList* self, gint position, gconstpointer item);
	void (*insert_all) (MyIList* self, gint position, gpointer* items, int items_length1);
	void (*insert_collection) (MyIList* self, gint position, MyIList* coll);
	void (*reverse) (MyIList* self);
	gint (*index_of) (MyIList* self, gconstpointer item);
	gint* (*index_of_all) (MyIList* self, gconstpointer item, int* result_length1);
	void (*remove) (MyIList* self, gconstpointer item);
	void (*remove_at) (MyIList* self, gint index);
	void (*remove_all) (MyIList* self, gconstpointer item);
	void (*remove_range) (MyIList* self, gint start, gint length);
	gint (*get_size) (MyIList* self);
};

struct _MyIterableIface {
	GTypeInterface parent_iface;
	MyIterator* (*iterator) (MyIterable* self);
};

struct _MyIEquatableIface {
	GTypeInterface parent_iface;
	gboolean (*equals) (MyIEquatable* self, GObject* other);
};

struct _MyList {
	GObject parent_instance;
	MyListPrivate * priv;
};

struct _MyListClass {
	GObjectClass parent_class;
};

struct _MyByteVector {
	MyList parent_instance;
	MyByteVectorPrivate * priv;
};

struct _MyByteVectorClass {
	MyListClass parent_class;
};

struct _MyByteVectorCollection {
	MyList parent_instance;
	MyByteVectorCollectionPrivate * priv;
};

struct _MyByteVectorCollectionClass {
	MyListClass parent_class;
};


static gpointer my_byte_vector_parent_class = NULL;
static gpointer my_byte_vector_collection_parent_class = NULL;

GType my_ilist_get_type (void) G_GNUC_CONST;
gpointer my_iterator_ref (gpointer instance);
void my_iterator_unref (gpointer instance);
GParamSpec* my_param_spec_iterator (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void my_value_set_iterator (GValue* value, gpointer v_object);
void my_value_take_iterator (GValue* value, gpointer v_object);
gpointer my_value_get_iterator (const GValue* value);
GType my_iterator_get_type (void) G_GNUC_CONST;
GType my_iterable_get_type (void) G_GNUC_CONST;
GType my_iequatable_get_type (void) G_GNUC_CONST;
GType my_list_get_type (void) G_GNUC_CONST;
GType my_byte_vector_get_type (void) G_GNUC_CONST;
enum  {
	MY_BYTE_VECTOR_DUMMY_PROPERTY
};
MyByteVector* my_byte_vector_new (const gchar* init);
MyByteVector* my_byte_vector_construct (GType object_type, const gchar* init);
MyList* my_list_new (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GEqualFunc func, GCompareFunc cfunc);
MyList* my_list_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GEqualFunc func, GCompareFunc cfunc);
void my_byte_vector_add_string (MyByteVector* self, const gchar* str);
void my_ilist_add (MyIList* self, gconstpointer item);
gchar* my_byte_vector_substring (MyByteVector* self, gint start, gint end);
gint my_ilist_get_size (MyIList* self);
MyList* my_list_slice (MyList* self, gint start, gint end);
gchar* my_byte_vector_to_string (MyByteVector* self);
MyByteVector* my_byte_vector_mid (MyByteVector* self, gint start, gint length);
gpointer my_ilist_get (MyIList* self, gint index);
guint my_byte_vector_to_uint (MyByteVector* self, gboolean most);
gulong my_byte_vector_to_ulong (MyByteVector* self, gboolean most);
gushort my_byte_vector_to_ushort (MyByteVector* self, gboolean most);
MyByteVector* my_byte_vector_from_ulong (gulong value, gboolean most);
MyByteVector* my_byte_vector_from_uint (guint value, gboolean most);
GType my_byte_vector_collection_get_type (void) G_GNUC_CONST;
enum  {
	MY_BYTE_VECTOR_COLLECTION_DUMMY_PROPERTY
};
MyByteVectorCollection* my_byte_vector_collection_new (void);
MyByteVectorCollection* my_byte_vector_collection_construct (GType object_type);
MyByteVector* my_byte_vector_collection_to_bytevector (MyByteVectorCollection* self, MyByteVector* separator);
void my_ilist_add_collection (MyIList* self, MyIList* coll);


MyByteVector* my_byte_vector_construct (GType object_type, const gchar* init) {
	MyByteVector * self = NULL;
	const gchar* _tmp0_;
	g_return_val_if_fail (init != NULL, NULL);
	self = (MyByteVector*) my_list_construct (object_type, G_TYPE_UCHAR, NULL, NULL, NULL, NULL);
	_tmp0_ = init;
	my_byte_vector_add_string (self, _tmp0_);
	return self;
}


MyByteVector* my_byte_vector_new (const gchar* init) {
	return my_byte_vector_construct (MY_TYPE_BYTE_VECTOR, init);
}


static gunichar string_get_char (const gchar* self, glong index) {
	gunichar result = 0U;
	glong _tmp0_;
	gunichar _tmp1_ = 0U;
	g_return_val_if_fail (self != NULL, 0U);
	_tmp0_ = index;
	_tmp1_ = g_utf8_get_char (((gchar*) self) + _tmp0_);
	result = _tmp1_;
	return result;
}


void my_byte_vector_add_string (MyByteVector* self, const gchar* str) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (str != NULL);
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				gboolean _tmp1_;
				gint _tmp3_;
				const gchar* _tmp4_;
				gint _tmp5_;
				gint _tmp6_;
				const gchar* _tmp7_;
				gint _tmp8_;
				gunichar _tmp9_ = 0U;
				_tmp1_ = _tmp0_;
				if (!_tmp1_) {
					gint _tmp2_;
					_tmp2_ = i;
					i = _tmp2_ + 1;
				}
				_tmp0_ = FALSE;
				_tmp3_ = i;
				_tmp4_ = str;
				_tmp5_ = strlen (_tmp4_);
				_tmp6_ = _tmp5_;
				if (!(_tmp3_ < _tmp6_)) {
					break;
				}
				_tmp7_ = str;
				_tmp8_ = i;
				_tmp9_ = string_get_char (_tmp7_, (glong) _tmp8_);
				my_ilist_add ((MyIList*) self, (gpointer) ((guintptr) ((guint8) _tmp9_)));
			}
		}
	}
}


gchar* my_byte_vector_substring (MyByteVector* self, gint start, gint end) {
	gchar* result = NULL;
	gint _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	gint _tmp5_;
	gint _tmp6_;
	MyList* _tmp7_ = NULL;
	MyByteVector* _tmp8_;
	MyByteVector* bv;
	gchar* _tmp9_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = end;
	_tmp1_ = my_ilist_get_size ((MyIList*) self);
	_tmp2_ = _tmp1_;
	if (_tmp0_ >= _tmp2_) {
		gint _tmp3_;
		gint _tmp4_;
		_tmp3_ = my_ilist_get_size ((MyIList*) self);
		_tmp4_ = _tmp3_;
		end = _tmp4_ - 1;
	}
	_tmp5_ = start;
	_tmp6_ = end;
	_tmp7_ = my_list_slice ((MyList*) self, _tmp5_, _tmp6_);
	_tmp8_ = G_TYPE_CHECK_INSTANCE_TYPE (_tmp7_, MY_TYPE_BYTE_VECTOR) ? ((MyByteVector*) _tmp7_) : NULL;
	if (_tmp8_ == NULL) {
		_g_object_unref0 (_tmp7_);
	}
	bv = _tmp8_;
	_tmp9_ = my_byte_vector_to_string (bv);
	result = _tmp9_;
	_g_object_unref0 (bv);
	return result;
}


MyByteVector* my_byte_vector_mid (MyByteVector* self, gint start, gint length) {
	MyByteVector* result = NULL;
	MyByteVector* _tmp0_;
	MyByteVector* bv;
	gint _tmp1_;
	gint _tmp2_;
	gint _tmp3_;
	gint _tmp4_;
	gint _tmp5_;
	gint _tmp6_;
	gint _tmp7_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = my_byte_vector_new ("");
	bv = _tmp0_;
	_tmp1_ = length;
	_tmp2_ = my_ilist_get_size ((MyIList*) self);
	_tmp3_ = _tmp2_;
	if (_tmp1_ > _tmp3_) {
		result = bv;
		return result;
	}
	_tmp4_ = start;
	_tmp5_ = length;
	_tmp6_ = my_ilist_get_size ((MyIList*) self);
	_tmp7_ = _tmp6_;
	if ((_tmp4_ + _tmp5_) > _tmp7_) {
		result = bv;
		return result;
	}
	{
		gint _tmp8_;
		gint i;
		_tmp8_ = start;
		i = _tmp8_;
		{
			gboolean _tmp9_;
			_tmp9_ = TRUE;
			while (TRUE) {
				gboolean _tmp10_;
				gint _tmp12_;
				gint _tmp13_;
				MyByteVector* _tmp14_;
				gint _tmp15_;
				gpointer _tmp16_ = NULL;
				_tmp10_ = _tmp9_;
				if (!_tmp10_) {
					gint _tmp11_;
					_tmp11_ = i;
					i = _tmp11_ + 1;
				}
				_tmp9_ = FALSE;
				_tmp12_ = i;
				_tmp13_ = length;
				if (!(_tmp12_ < _tmp13_)) {
					break;
				}
				_tmp14_ = bv;
				_tmp15_ = i;
				_tmp16_ = my_ilist_get ((MyIList*) self, _tmp15_);
				my_ilist_add ((MyIList*) _tmp14_, (gpointer) ((guintptr) ((guint8) ((guintptr) _tmp16_))));
			}
		}
	}
	result = bv;
	return result;
}


guint my_byte_vector_to_uint (MyByteVector* self, gboolean most) {
	guint result = 0U;
	guint sum;
	gint _tmp0_ = 0;
	gint _tmp1_;
	gint _tmp2_;
	gint _tmp5_;
	gint last;
	g_return_val_if_fail (self != NULL, 0U);
	sum = (guint) 0;
	_tmp1_ = my_ilist_get_size ((MyIList*) self);
	_tmp2_ = _tmp1_;
	if (_tmp2_ > 4) {
		_tmp0_ = 3;
	} else {
		gint _tmp3_;
		gint _tmp4_;
		_tmp3_ = my_ilist_get_size ((MyIList*) self);
		_tmp4_ = _tmp3_;
		_tmp0_ = _tmp4_ - 1;
	}
	_tmp5_ = _tmp0_;
	last = _tmp5_;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp6_;
			_tmp6_ = TRUE;
			while (TRUE) {
				gboolean _tmp7_;
				gint _tmp9_;
				gint _tmp10_;
				gint _tmp11_ = 0;
				gboolean _tmp12_;
				gint _tmp16_;
				gint offset;
				guint _tmp17_;
				gint _tmp18_;
				gpointer _tmp19_ = NULL;
				gint _tmp20_;
				_tmp7_ = _tmp6_;
				if (!_tmp7_) {
					gint _tmp8_;
					_tmp8_ = i;
					i = _tmp8_ + 1;
				}
				_tmp6_ = FALSE;
				_tmp9_ = i;
				_tmp10_ = last;
				if (!(_tmp9_ <= _tmp10_)) {
					break;
				}
				_tmp12_ = most;
				if (_tmp12_) {
					gint _tmp13_;
					gint _tmp14_;
					_tmp13_ = last;
					_tmp14_ = i;
					_tmp11_ = _tmp13_ - _tmp14_;
				} else {
					gint _tmp15_;
					_tmp15_ = i;
					_tmp11_ = _tmp15_;
				}
				_tmp16_ = _tmp11_;
				offset = _tmp16_;
				_tmp17_ = sum;
				_tmp18_ = i;
				_tmp19_ = my_ilist_get ((MyIList*) self, _tmp18_);
				_tmp20_ = offset;
				sum = _tmp17_ | ((guint) (((gint) ((guint8) ((guintptr) _tmp19_))) << (_tmp20_ * 8)));
			}
		}
	}
	result = sum;
	return result;
}


gulong my_byte_vector_to_ulong (MyByteVector* self, gboolean most) {
	gulong result = 0UL;
	gulong sum;
	gint _tmp0_ = 0;
	gint _tmp1_;
	gint _tmp2_;
	gint _tmp5_;
	gint last;
	g_return_val_if_fail (self != NULL, 0UL);
	sum = (gulong) 0;
	_tmp1_ = my_ilist_get_size ((MyIList*) self);
	_tmp2_ = _tmp1_;
	if (_tmp2_ > 8) {
		_tmp0_ = 7;
	} else {
		gint _tmp3_;
		gint _tmp4_;
		_tmp3_ = my_ilist_get_size ((MyIList*) self);
		_tmp4_ = _tmp3_;
		_tmp0_ = _tmp4_ - 1;
	}
	_tmp5_ = _tmp0_;
	last = _tmp5_;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp6_;
			_tmp6_ = TRUE;
			while (TRUE) {
				gboolean _tmp7_;
				gint _tmp9_;
				gint _tmp10_;
				gint _tmp11_ = 0;
				gboolean _tmp12_;
				gint _tmp16_;
				gint offset;
				gulong _tmp17_;
				gint _tmp18_;
				gpointer _tmp19_ = NULL;
				gint _tmp20_;
				_tmp7_ = _tmp6_;
				if (!_tmp7_) {
					gint _tmp8_;
					_tmp8_ = i;
					i = _tmp8_ + 1;
				}
				_tmp6_ = FALSE;
				_tmp9_ = i;
				_tmp10_ = last;
				if (!(_tmp9_ <= _tmp10_)) {
					break;
				}
				_tmp12_ = most;
				if (_tmp12_) {
					gint _tmp13_;
					gint _tmp14_;
					_tmp13_ = last;
					_tmp14_ = i;
					_tmp11_ = _tmp13_ - _tmp14_;
				} else {
					gint _tmp15_;
					_tmp15_ = i;
					_tmp11_ = _tmp15_;
				}
				_tmp16_ = _tmp11_;
				offset = _tmp16_;
				_tmp17_ = sum;
				_tmp18_ = i;
				_tmp19_ = my_ilist_get ((MyIList*) self, _tmp18_);
				_tmp20_ = offset;
				sum = _tmp17_ | ((gulong) (((gint) ((guint8) ((guintptr) _tmp19_))) << (_tmp20_ * 8)));
			}
		}
	}
	result = sum;
	return result;
}


gushort my_byte_vector_to_ushort (MyByteVector* self, gboolean most) {
	gushort result = 0U;
	gushort sum;
	gint _tmp0_ = 0;
	gint _tmp1_;
	gint _tmp2_;
	gint _tmp5_;
	gint last;
	g_return_val_if_fail (self != NULL, 0U);
	sum = (gushort) 0;
	_tmp1_ = my_ilist_get_size ((MyIList*) self);
	_tmp2_ = _tmp1_;
	if (_tmp2_ > 2) {
		_tmp0_ = 1;
	} else {
		gint _tmp3_;
		gint _tmp4_;
		_tmp3_ = my_ilist_get_size ((MyIList*) self);
		_tmp4_ = _tmp3_;
		_tmp0_ = _tmp4_ - 1;
	}
	_tmp5_ = _tmp0_;
	last = _tmp5_;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp6_;
			_tmp6_ = TRUE;
			while (TRUE) {
				gboolean _tmp7_;
				gint _tmp9_;
				gint _tmp10_;
				gint _tmp11_ = 0;
				gboolean _tmp12_;
				gint _tmp16_;
				gint offset;
				gushort _tmp17_;
				gint _tmp18_;
				gpointer _tmp19_ = NULL;
				gint _tmp20_;
				_tmp7_ = _tmp6_;
				if (!_tmp7_) {
					gint _tmp8_;
					_tmp8_ = i;
					i = _tmp8_ + 1;
				}
				_tmp6_ = FALSE;
				_tmp9_ = i;
				_tmp10_ = last;
				if (!(_tmp9_ <= _tmp10_)) {
					break;
				}
				_tmp12_ = most;
				if (_tmp12_) {
					gint _tmp13_;
					gint _tmp14_;
					_tmp13_ = last;
					_tmp14_ = i;
					_tmp11_ = _tmp13_ - _tmp14_;
				} else {
					gint _tmp15_;
					_tmp15_ = i;
					_tmp11_ = _tmp15_;
				}
				_tmp16_ = _tmp11_;
				offset = _tmp16_;
				_tmp17_ = sum;
				_tmp18_ = i;
				_tmp19_ = my_ilist_get ((MyIList*) self, _tmp18_);
				_tmp20_ = offset;
				sum = _tmp17_ | ((gushort) (((gint) ((guint8) ((guintptr) _tmp19_))) << (_tmp20_ * 8)));
			}
		}
	}
	result = sum;
	return result;
}


MyByteVector* my_byte_vector_from_ulong (gulong value, gboolean most) {
	MyByteVector* result = NULL;
	MyByteVector* _tmp0_;
	MyByteVector* vector;
	_tmp0_ = my_byte_vector_new ("");
	vector = _tmp0_;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				gboolean _tmp2_;
				gint _tmp4_;
				gint _tmp5_ = 0;
				gboolean _tmp6_;
				gint _tmp9_;
				gint offset;
				MyByteVector* _tmp10_;
				gulong _tmp11_;
				gint _tmp12_;
				_tmp2_ = _tmp1_;
				if (!_tmp2_) {
					gint _tmp3_;
					_tmp3_ = i;
					i = _tmp3_ + 1;
				}
				_tmp1_ = FALSE;
				_tmp4_ = i;
				if (!(_tmp4_ < 8)) {
					break;
				}
				_tmp6_ = most;
				if (_tmp6_) {
					gint _tmp7_;
					_tmp7_ = i;
					_tmp5_ = 7 - _tmp7_;
				} else {
					gint _tmp8_;
					_tmp8_ = i;
					_tmp5_ = _tmp8_;
				}
				_tmp9_ = _tmp5_;
				offset = _tmp9_;
				_tmp10_ = vector;
				_tmp11_ = value;
				_tmp12_ = offset;
				my_ilist_add ((MyIList*) _tmp10_, (gpointer) ((guintptr) ((guint8) ((_tmp11_ >> (_tmp12_ * 8)) & 0xFF))));
			}
		}
	}
	result = vector;
	return result;
}


MyByteVector* my_byte_vector_from_uint (guint value, gboolean most) {
	MyByteVector* result = NULL;
	MyByteVector* _tmp0_;
	MyByteVector* vector;
	_tmp0_ = my_byte_vector_new ("");
	vector = _tmp0_;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				gboolean _tmp2_;
				gint _tmp4_;
				gint _tmp5_ = 0;
				gboolean _tmp6_;
				gint _tmp9_;
				gint offset;
				MyByteVector* _tmp10_;
				guint _tmp11_;
				gint _tmp12_;
				_tmp2_ = _tmp1_;
				if (!_tmp2_) {
					gint _tmp3_;
					_tmp3_ = i;
					i = _tmp3_ + 1;
				}
				_tmp1_ = FALSE;
				_tmp4_ = i;
				if (!(_tmp4_ < 4)) {
					break;
				}
				_tmp6_ = most;
				if (_tmp6_) {
					gint _tmp7_;
					_tmp7_ = i;
					_tmp5_ = 3 - _tmp7_;
				} else {
					gint _tmp8_;
					_tmp8_ = i;
					_tmp5_ = _tmp8_;
				}
				_tmp9_ = _tmp5_;
				offset = _tmp9_;
				_tmp10_ = vector;
				_tmp11_ = value;
				_tmp12_ = offset;
				my_ilist_add ((MyIList*) _tmp10_, (gpointer) ((guintptr) ((guint8) ((_tmp11_ >> (_tmp12_ * 8)) & 0xFF))));
			}
		}
	}
	result = vector;
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


gchar* my_byte_vector_to_string (MyByteVector* self) {
	gchar* result = NULL;
	gchar* _tmp0_;
	gchar* s;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup ("");
	s = _tmp0_;
	{
		MyByteVector* _tmp1_;
		MyByteVector* _u_list;
		MyByteVector* _tmp2_;
		gint _tmp3_;
		gint _tmp4_;
		gint _u_size;
		gint _u_index;
		_tmp1_ = _g_object_ref0 (self);
		_u_list = _tmp1_;
		_tmp2_ = _u_list;
		_tmp3_ = my_ilist_get_size ((MyIList*) _tmp2_);
		_tmp4_ = _tmp3_;
		_u_size = _tmp4_;
		_u_index = -1;
		while (TRUE) {
			gint _tmp5_;
			gint _tmp6_;
			gint _tmp7_;
			MyByteVector* _tmp8_;
			gint _tmp9_;
			gpointer _tmp10_ = NULL;
			guint8 u;
			const gchar* _tmp11_;
			guint8 _tmp12_;
			gchar* _tmp13_ = NULL;
			gchar* _tmp14_;
			_tmp5_ = _u_index;
			_u_index = _tmp5_ + 1;
			_tmp6_ = _u_index;
			_tmp7_ = _u_size;
			if (!(_tmp6_ < _tmp7_)) {
				break;
			}
			_tmp8_ = _u_list;
			_tmp9_ = _u_index;
			_tmp10_ = my_ilist_get ((MyIList*) _tmp8_, _tmp9_);
			u = (guint8) ((guintptr) _tmp10_);
			_tmp11_ = s;
			_tmp12_ = u;
			_tmp13_ = g_strdup_printf ("%c", (gchar) _tmp12_);
			_tmp14_ = g_strconcat (_tmp11_, _tmp13_, NULL);
			s = _tmp14_;
		}
		_g_object_unref0 (_u_list);
	}
	result = s;
	return result;
}


static void my_byte_vector_class_init (MyByteVectorClass * klass) {
	my_byte_vector_parent_class = g_type_class_peek_parent (klass);
}


static void my_byte_vector_instance_init (MyByteVector * self) {
}


GType my_byte_vector_get_type (void) {
	static volatile gsize my_byte_vector_type_id__volatile = 0;
	if (g_once_init_enter (&my_byte_vector_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (MyByteVectorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) my_byte_vector_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MyByteVector), 0, (GInstanceInitFunc) my_byte_vector_instance_init, NULL };
		GType my_byte_vector_type_id;
		my_byte_vector_type_id = g_type_register_static (MY_TYPE_LIST, "MyByteVector", &g_define_type_info, 0);
		g_once_init_leave (&my_byte_vector_type_id__volatile, my_byte_vector_type_id);
	}
	return my_byte_vector_type_id__volatile;
}


MyByteVectorCollection* my_byte_vector_collection_construct (GType object_type) {
	MyByteVectorCollection * self = NULL;
	self = (MyByteVectorCollection*) my_list_construct (object_type, MY_TYPE_BYTE_VECTOR, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL);
	return self;
}


MyByteVectorCollection* my_byte_vector_collection_new (void) {
	return my_byte_vector_collection_construct (MY_TYPE_BYTE_VECTOR_COLLECTION);
}


MyByteVector* my_byte_vector_collection_to_bytevector (MyByteVectorCollection* self, MyByteVector* separator) {
	MyByteVector* result = NULL;
	MyByteVector* _tmp0_;
	MyByteVector* bv;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (separator != NULL, NULL);
	_tmp0_ = my_byte_vector_new ("");
	bv = _tmp0_;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				gboolean _tmp2_;
				gint _tmp4_;
				gint _tmp5_;
				gint _tmp6_;
				gboolean _tmp7_ = FALSE;
				gint _tmp8_;
				gboolean _tmp12_;
				MyByteVector* _tmp15_;
				gint _tmp16_;
				gpointer _tmp17_ = NULL;
				MyByteVector* _tmp18_;
				_tmp2_ = _tmp1_;
				if (!_tmp2_) {
					gint _tmp3_;
					_tmp3_ = i;
					i = _tmp3_ + 1;
				}
				_tmp1_ = FALSE;
				_tmp4_ = i;
				_tmp5_ = my_ilist_get_size ((MyIList*) self);
				_tmp6_ = _tmp5_;
				if (!(_tmp4_ < _tmp6_)) {
					break;
				}
				_tmp8_ = i;
				if (_tmp8_ != 0) {
					MyByteVector* _tmp9_;
					gint _tmp10_;
					gint _tmp11_;
					_tmp9_ = separator;
					_tmp10_ = my_ilist_get_size ((MyIList*) _tmp9_);
					_tmp11_ = _tmp10_;
					_tmp7_ = _tmp11_ > 0;
				} else {
					_tmp7_ = FALSE;
				}
				_tmp12_ = _tmp7_;
				if (_tmp12_) {
					MyByteVector* _tmp13_;
					MyByteVector* _tmp14_;
					_tmp13_ = bv;
					_tmp14_ = separator;
					my_ilist_add_collection ((MyIList*) _tmp13_, (MyIList*) _tmp14_);
				}
				_tmp15_ = bv;
				_tmp16_ = i;
				_tmp17_ = my_ilist_get ((MyIList*) self, _tmp16_);
				_tmp18_ = (MyByteVector*) _tmp17_;
				my_ilist_add_collection ((MyIList*) _tmp15_, (MyIList*) _tmp18_);
				_g_object_unref0 (_tmp18_);
			}
		}
	}
	result = bv;
	return result;
}


static void my_byte_vector_collection_class_init (MyByteVectorCollectionClass * klass) {
	my_byte_vector_collection_parent_class = g_type_class_peek_parent (klass);
}


static void my_byte_vector_collection_instance_init (MyByteVectorCollection * self) {
}


GType my_byte_vector_collection_get_type (void) {
	static volatile gsize my_byte_vector_collection_type_id__volatile = 0;
	if (g_once_init_enter (&my_byte_vector_collection_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (MyByteVectorCollectionClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) my_byte_vector_collection_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MyByteVectorCollection), 0, (GInstanceInitFunc) my_byte_vector_collection_instance_init, NULL };
		GType my_byte_vector_collection_type_id;
		my_byte_vector_collection_type_id = g_type_register_static (MY_TYPE_LIST, "MyByteVectorCollection", &g_define_type_info, 0);
		g_once_init_leave (&my_byte_vector_collection_type_id__volatile, my_byte_vector_collection_type_id);
	}
	return my_byte_vector_collection_type_id__volatile;
}




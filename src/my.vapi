/* my.vapi generated by valac 0.20.0, do not modify. */

namespace My {
	namespace Functions {
		[CCode (cheader_filename = "my.h")]
		public static GLib.CompareFunc compare_func_for (GLib.Type t);
		[CCode (cheader_filename = "my.h")]
		public static int direct_compare (void* _val1, void* _val2);
		[CCode (cheader_filename = "my.h")]
		public static GLib.EqualFunc equal_func_for (GLib.Type t);
	}
	[CCode (cheader_filename = "my.h")]
	public class ByteVector : My.List<uint8> {
		public ByteVector (string init = "");
		public void add_string (string str);
		public static My.ByteVector from_uint (uint value, bool most);
		public static My.ByteVector from_ulong (ulong value, bool most);
		public My.ByteVector mid (int start, int length);
		public string substring (int start, int end = @this.size - 1);
		public string to_string ();
		public uint to_uint (bool most = true);
		public ulong to_ulong (bool most = true);
		public ushort to_ushort (bool most = true);
	}
	[CCode (cheader_filename = "my.h")]
	public class ByteVectorCollection : My.List<My.ByteVector> {
		public ByteVectorCollection ();
		public My.ByteVector to_bytevector (My.ByteVector separator);
	}
	[CCode (cheader_filename = "my.h")]
	public class Dictionary<K,V> : My.IDictionary<K,V>, GLib.Object {
		public Dictionary (GLib.EqualFunc key_equal = null, GLib.EqualFunc value_equal = null);
		public My.IList<My.Entry<K,V>> entries { get; }
		public GLib.EqualFunc keys_func { get; }
		public GLib.EqualFunc values_func { get; }
	}
	[CCode (cheader_filename = "my.h")]
	public class Entry<K,V> {
		public Entry (K k = null, V v = null);
		public K key { get; set; }
		public V value { get; set; }
	}
	[CCode (cheader_filename = "my.h")]
	public class Iterator<G> {
		public Iterator (My.IList i);
		public G @get ();
		public bool next ();
		public bool prev ();
	}
	[CCode (cheader_filename = "my.h")]
	public class List<G> : My.IList<G>, My.Iterable<G>, My.IEquatable, GLib.Object {
		public List (GLib.EqualFunc func = null, GLib.CompareFunc cfunc = null);
		public void clear ();
		public My.List<G> slice (int start, int end);
		public void sort ();
		public G[] to_array ();
		public GLib.EqualFunc equal_func { get; }
	}
	[CCode (cheader_filename = "my.h")]
	public class PtrList : My.List<weak void*> {
		public PtrList ();
		public void** data { get; }
	}
	[CCode (cheader_filename = "my.h")]
	public interface IDictionary<K,V> : GLib.Object {
		public abstract void add (K key, V val);
		public abstract V @get (K key);
		public abstract bool has_key (K key);
		public abstract bool has_value (V val);
		public abstract void @set (K key, V val);
		public abstract bool unset (K key, out V val);
		public abstract My.IList<K> keys { get; }
		public abstract int size { get; }
		public abstract My.IList<V> values { get; }
	}
	[CCode (cheader_filename = "my.h")]
	public interface IEquatable : GLib.Object {
		public abstract bool equals (GLib.Object other);
	}
	[CCode (cheader_filename = "my.h")]
	public interface IList<G> : GLib.Object {
		public abstract void add (G item);
		public abstract void add_collection (My.IList<G> coll);
		public abstract void add_range (G[] items);
		public abstract bool contains (G item);
		public abstract G @get (int index);
		public abstract int index_of (G item);
		public abstract int[] index_of_all (G item);
		public abstract void insert (int position, G item);
		public abstract void insert_all (int position, G[] items);
		public abstract void insert_collection (int position, My.IList<G> coll);
		public abstract void remove (G item);
		public abstract void remove_all (G item);
		public abstract void remove_at (int index);
		public abstract void remove_range (int start, int length);
		public abstract void reverse ();
		public abstract void @set (int index, G val);
		public abstract int size { get; }
	}
	[CCode (cheader_filename = "my.h")]
	public interface Iterable<G> : GLib.Object {
		public abstract My.Iterator<G> iterator ();
	}
}
